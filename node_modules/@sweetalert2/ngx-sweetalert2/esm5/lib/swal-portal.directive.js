/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ApplicationRef, ComponentFactoryResolver, Directive, Host, Injector, Input, TemplateRef } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { SwalPortalTargets } from './swal-portal-targets.service';
import { SwalPortalComponent } from './swal-portal.component';
import { SwalComponent } from './swal.component';
import { SweetAlert2LoaderService } from './sweetalert2-loader.service';
/**
 * A structural directive that lets you use Angular templates inside of SweetAlerts.
 * There are different targetable zones provided by {\@link SwalPortalTargets}: title, content, confirmButton, etc, but
 * you can also make your own target by implementing {\@link SwalPortalTarget} and giving it to this directive.
 * The default target is the alert text content zone.
 *
 * Usage in your component's TypeScript (if you use another target than {\@link SwalPortalTargets.content}):
 *
 * \@Component({ ... })
 *     export class MyComponent {
 *         public constructor(public readonly swalTargets: SwalPortalTargets) {
 *         }
 *     }
 *
 * Usage in the template:
 *
 *     <swal title="Fill the form" (confirm)="confirmHandler()">
 *         <!-- This form will be displayed as the alert main content
 *              Targets the alert's main content zone by default -->
 *         <form *swalPortal [formControl]="myForm">
 *             ...
 *         </form>
 *
 *         <!-- This targets the confirm button's inner content
 *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->
 *         <ng-container *swalPortal="swalTargets.confirmButton">
 *              Send ({{ secondsLeft }} seconds left)
 *         </ng-container>
 *     <swal>
 */
var SwalPortalDirective = /** @class */ (function () {
    function SwalPortalDirective(resolver, injector, app, templateRef, sweetAlert2Loader, swalTargets, swalComponent) {
        this.resolver = resolver;
        this.injector = injector;
        this.app = app;
        this.templateRef = templateRef;
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.swalTargets = swalTargets;
        this.swalComponent = swalComponent;
        this.destroyed = new Subject();
    }
    /**
     * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
     * that will receive the consumer's template.
     */
    /**
     * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
     * that will receive the consumer's template.
     * @return {?}
     */
    SwalPortalDirective.prototype.ngOnInit = /**
     * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
     * that will receive the consumer's template.
     * @return {?}
     */
    function () {
        // Can't be set in a default property value, if the customer lets *swalPortal empty, the value we get is undef.
        this.target = this.target || this.swalTargets.content;
        //=> Apply the options provided by the target definition
        void this.swalComponent.update(this.target.options);
        //=> Subscribe to a few hooks frm the parent SwalComponent.
        this.swalComponent.render.pipe(takeUntil(this.destroyed)).subscribe(this.renderHook.bind(this));
        this.swalComponent.beforeOpen.pipe(takeUntil(this.destroyed)).subscribe(this.beforeOpenHook.bind(this));
        this.swalComponent.afterClose.pipe(takeUntil(this.destroyed)).subscribe(this.afterCloseHook.bind(this));
    };
    /**
     * Signal any {@link destroyed} consumer that this is over, so they can unsubscribe from the
     * parent SwalComponent events.
     */
    /**
     * Signal any {\@link destroyed} consumer that this is over, so they can unsubscribe from the
     * parent SwalComponent events.
     * @return {?}
     */
    SwalPortalDirective.prototype.ngOnDestroy = /**
     * Signal any {\@link destroyed} consumer that this is over, so they can unsubscribe from the
     * parent SwalComponent events.
     * @return {?}
     */
    function () {
        this.destroyed.next();
    };
    /**
     * This render hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
     * {@link beforeOpenHook}), or after Swal.update() is called.
     * This is a good place to render, or re-render, our portal contents.
     */
    /**
     * This render hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
     * {\@link beforeOpenHook}), or after Swal.update() is called.
     * This is a good place to render, or re-render, our portal contents.
     * @private
     * @return {?}
     */
    SwalPortalDirective.prototype.renderHook = /**
     * This render hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
     * {\@link beforeOpenHook}), or after Swal.update() is called.
     * This is a good place to render, or re-render, our portal contents.
     * @private
     * @return {?}
     */
    function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var swal, targetEl;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        //=> Ensure the portal component is created
                        if (!this.portalComponentRef) {
                            this.portalComponentRef = this.createPortalComponent();
                        }
                        //=> SweetAlert2 created the modal or just erased all of our content, so we need to install/reinstall it.
                        // Swal.update() is synchronous, this observable too, and mountComponentOnTarget too (the promise inside
                        // this function is already resolved at this point), so the whole process of re-rendering and re-mounting
                        // the portal component is fully synchronous, causing no blinks in the modal contents.
                        return [4 /*yield*/, this.sweetAlert2Loader.swal];
                    case 1:
                        swal = _a.sent();
                        //=> Find target element
                        targetEl = (/** @type {?} */ (this.target)).element(swal);
                        //=> Replace target's contents with our component
                        // https://jsperf.com/innerhtml-vs-removechild/15
                        while (targetEl.firstChild) {
                            targetEl.removeChild(targetEl.firstChild);
                        }
                        targetEl.appendChild(this.portalComponentRef.location.nativeElement);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * This beforeOpen hook runs once (per modal instance), just before the modal is shown on the screen.
     * This is a good place to declare our detached view to the Angular app.
     */
    /**
     * This beforeOpen hook runs once (per modal instance), just before the modal is shown on the screen.
     * This is a good place to declare our detached view to the Angular app.
     * @private
     * @return {?}
     */
    SwalPortalDirective.prototype.beforeOpenHook = /**
     * This beforeOpen hook runs once (per modal instance), just before the modal is shown on the screen.
     * This is a good place to declare our detached view to the Angular app.
     * @private
     * @return {?}
     */
    function () {
        if (!this.portalComponentRef)
            return;
        //=> Make the Angular app aware of that detached view so rendering and change detection can happen
        this.app.attachView(this.portalComponentRef.hostView);
    };
    /**
     * This afterClose hook runs once (per modal instance), just after the modal closing animation terminated.
     * This is a good place to detach and destroy our content, that is not visible anymore.
     */
    /**
     * This afterClose hook runs once (per modal instance), just after the modal closing animation terminated.
     * This is a good place to detach and destroy our content, that is not visible anymore.
     * @private
     * @return {?}
     */
    SwalPortalDirective.prototype.afterCloseHook = /**
     * This afterClose hook runs once (per modal instance), just after the modal closing animation terminated.
     * This is a good place to detach and destroy our content, that is not visible anymore.
     * @private
     * @return {?}
     */
    function () {
        if (!this.portalComponentRef)
            return;
        //=> Detach the portal component from the app and destroy it
        this.app.detachView(this.portalComponentRef.hostView);
        this.portalComponentRef.destroy();
        this.portalComponentRef = void 0;
    };
    /**
     * Creates the {@link SwalPortalComponent} and gives it the customer's template ref.
     */
    /**
     * Creates the {\@link SwalPortalComponent} and gives it the customer's template ref.
     * @private
     * @return {?}
     */
    SwalPortalDirective.prototype.createPortalComponent = /**
     * Creates the {\@link SwalPortalComponent} and gives it the customer's template ref.
     * @private
     * @return {?}
     */
    function () {
        //=> Create the SwalPortalComponent that will hold our content
        /** @type {?} */
        var factory = this.resolver.resolveComponentFactory(SwalPortalComponent);
        // Yes, we do not use the third argument that would directly use the target as the component's view
        // (unfortunately, because that would give a cleaner DOM and would avoid dirty and direct DOM manipulations)
        // That's because we want to keep our component safe from SweetAlert2's operations on the DOM, and to be
        // able to restore it at any moment, ie. after the modal has been re-rendered.
        /** @type {?} */
        var componentRef = factory.create(this.injector, []);
        //=> Apply the consumer's template on the component
        componentRef.instance.template = this.templateRef;
        return componentRef;
    };
    SwalPortalDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[swalPortal]'
                },] }
    ];
    /** @nocollapse */
    SwalPortalDirective.ctorParameters = function () { return [
        { type: ComponentFactoryResolver },
        { type: Injector },
        { type: ApplicationRef },
        { type: TemplateRef },
        { type: SweetAlert2LoaderService },
        { type: SwalPortalTargets },
        { type: SwalComponent, decorators: [{ type: Host }] }
    ]; };
    SwalPortalDirective.propDecorators = {
        target: [{ type: Input, args: ['swalPortal',] }]
    };
    return SwalPortalDirective;
}());
export { SwalPortalDirective };
if (false) {
    /**
     * Takes a portal target or nothing (then it will target the text content zone by default).
     *
     * See the {\@link SwalPortalTargets} service to see the available targets.
     * See the class doc block for more informations.
     * @type {?}
     */
    SwalPortalDirective.prototype.target;
    /**
     * Holds the component reference of the controlled SwalPortalComponent to destroy it when no longer needed.
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.portalComponentRef;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.destroyed;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.resolver;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.injector;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.app;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.sweetAlert2Loader;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.swalTargets;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.swalComponent;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC1wb3J0YWwuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHN3ZWV0YWxlcnQyL25neC1zd2VldGFsZXJ0Mi8iLCJzb3VyY2VzIjpbImxpYi9zd2FsLXBvcnRhbC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQ0gsY0FBYyxFQUFFLHdCQUF3QixFQUFnQixTQUFTLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQ3hGLFdBQVcsRUFDZCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQW9CLGlCQUFpQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDcEYsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2pELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDhCQUE4QixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0N4RTtJQW1CSSw2QkFDcUIsUUFBa0MsRUFDbEMsUUFBa0IsRUFDbEIsR0FBbUIsRUFDbkIsV0FBNkIsRUFDN0IsaUJBQTJDLEVBQzNDLFdBQThCLEVBQ3RCLGFBQTRCO1FBTnBDLGFBQVEsR0FBUixRQUFRLENBQTBCO1FBQ2xDLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDbEIsUUFBRyxHQUFILEdBQUcsQ0FBZ0I7UUFDbkIsZ0JBQVcsR0FBWCxXQUFXLENBQWtCO1FBQzdCLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBMEI7UUFDM0MsZ0JBQVcsR0FBWCxXQUFXLENBQW1CO1FBQ3RCLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBVHhDLGNBQVMsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO0lBVWpE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dUIsQ0FBQyxtQkFBbUIsQ0FBQzs7Ozs7O1lBTXBFLFlBQVksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDO1FBRXRELG1EQUFtRDtRQUNuRCxZQUFZLENBQUMsUUFBUSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBRWxELE9BQU8sWUFBWSxDQUFDO0lBQ3hCLENBQUM7O2dCQTVISixTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLGNBQWM7aUJBQzNCOzs7O2dCQTFDbUIsd0JBQXdCO2dCQUFpQyxRQUFRO2dCQUFqRixjQUFjO2dCQUNkLFdBQVc7Z0JBT04sd0JBQXdCO2dCQUhOLGlCQUFpQjtnQkFFbkMsYUFBYSx1QkEyRGIsSUFBSTs7O3lCQWhCUixLQUFLLFNBQUMsWUFBWTs7SUFtSHZCLDBCQUFDO0NBQUEsQUE3SEQsSUE2SEM7U0ExSFksbUJBQW1COzs7Ozs7Ozs7SUFPNUIscUNBQXNEOzs7Ozs7SUFLdEQsaURBQStEOzs7OztJQUUvRCx3Q0FBaUQ7Ozs7O0lBRzdDLHVDQUFtRDs7Ozs7SUFDbkQsdUNBQW1DOzs7OztJQUNuQyxrQ0FBb0M7Ozs7O0lBQ3BDLDBDQUE4Qzs7Ozs7SUFDOUMsZ0RBQTREOzs7OztJQUM1RCwwQ0FBK0M7Ozs7O0lBQy9DLDRDQUFxRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQXBwbGljYXRpb25SZWYsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBEaXJlY3RpdmUsIEhvc3QsIEluamVjdG9yLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsXG4gICAgVGVtcGxhdGVSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTd2FsUG9ydGFsVGFyZ2V0LCBTd2FsUG9ydGFsVGFyZ2V0cyB9IGZyb20gJy4vc3dhbC1wb3J0YWwtdGFyZ2V0cy5zZXJ2aWNlJztcbmltcG9ydCB7IFN3YWxQb3J0YWxDb21wb25lbnQgfSBmcm9tICcuL3N3YWwtcG9ydGFsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTd2FsQ29tcG9uZW50IH0gZnJvbSAnLi9zd2FsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTd2VldEFsZXJ0MkxvYWRlclNlcnZpY2UgfSBmcm9tICcuL3N3ZWV0YWxlcnQyLWxvYWRlci5zZXJ2aWNlJztcblxuLyoqXG4gKiBBIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHRoYXQgbGV0cyB5b3UgdXNlIEFuZ3VsYXIgdGVtcGxhdGVzIGluc2lkZSBvZiBTd2VldEFsZXJ0cy5cbiAqIFRoZXJlIGFyZSBkaWZmZXJlbnQgdGFyZ2V0YWJsZSB6b25lcyBwcm92aWRlZCBieSB7QGxpbmsgU3dhbFBvcnRhbFRhcmdldHN9OiB0aXRsZSwgY29udGVudCwgY29uZmlybUJ1dHRvbiwgZXRjLCBidXRcbiAqIHlvdSBjYW4gYWxzbyBtYWtlIHlvdXIgb3duIHRhcmdldCBieSBpbXBsZW1lbnRpbmcge0BsaW5rIFN3YWxQb3J0YWxUYXJnZXR9IGFuZCBnaXZpbmcgaXQgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKiBUaGUgZGVmYXVsdCB0YXJnZXQgaXMgdGhlIGFsZXJ0IHRleHQgY29udGVudCB6b25lLlxuICpcbiAqIFVzYWdlIGluIHlvdXIgY29tcG9uZW50J3MgVHlwZVNjcmlwdCAoaWYgeW91IHVzZSBhbm90aGVyIHRhcmdldCB0aGFuIHtAbGluayBTd2FsUG9ydGFsVGFyZ2V0cy5jb250ZW50fSk6XG4gKlxuICogICAgIEBDb21wb25lbnQoeyAuLi4gfSlcbiAqICAgICBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQge1xuICogICAgICAgICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHN3YWxUYXJnZXRzOiBTd2FsUG9ydGFsVGFyZ2V0cykge1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIFVzYWdlIGluIHRoZSB0ZW1wbGF0ZTpcbiAqXG4gKiAgICAgPHN3YWwgdGl0bGU9XCJGaWxsIHRoZSBmb3JtXCIgKGNvbmZpcm0pPVwiY29uZmlybUhhbmRsZXIoKVwiPlxuICogICAgICAgICA8IS0tIFRoaXMgZm9ybSB3aWxsIGJlIGRpc3BsYXllZCBhcyB0aGUgYWxlcnQgbWFpbiBjb250ZW50XG4gKiAgICAgICAgICAgICAgVGFyZ2V0cyB0aGUgYWxlcnQncyBtYWluIGNvbnRlbnQgem9uZSBieSBkZWZhdWx0IC0tPlxuICogICAgICAgICA8Zm9ybSAqc3dhbFBvcnRhbCBbZm9ybUNvbnRyb2xdPVwibXlGb3JtXCI+XG4gKiAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgPC9mb3JtPlxuICpcbiAqICAgICAgICAgPCEtLSBUaGlzIHRhcmdldHMgdGhlIGNvbmZpcm0gYnV0dG9uJ3MgaW5uZXIgY29udGVudFxuICogICAgICAgICAgICAgIE5vdGljZSB0aGUgdXNhZ2Ugb2YgbmctY29udGFpbmVyIHRvIGF2b2lkIGNyZWF0aW5nIGFuIHVzZWxlc3MgRE9NIGVsZW1lbnQgaW5zaWRlIHRoZSBidXR0b24gLS0+XG4gKiAgICAgICAgIDxuZy1jb250YWluZXIgKnN3YWxQb3J0YWw9XCJzd2FsVGFyZ2V0cy5jb25maXJtQnV0dG9uXCI+XG4gKiAgICAgICAgICAgICAgU2VuZCAoe3sgc2Vjb25kc0xlZnQgfX0gc2Vjb25kcyBsZWZ0KVxuICogICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAqICAgICA8c3dhbD5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbc3dhbFBvcnRhbF0nXG59KVxuZXhwb3J0IGNsYXNzIFN3YWxQb3J0YWxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBwb3J0YWwgdGFyZ2V0IG9yIG5vdGhpbmcgKHRoZW4gaXQgd2lsbCB0YXJnZXQgdGhlIHRleHQgY29udGVudCB6b25lIGJ5IGRlZmF1bHQpLlxuICAgICAqXG4gICAgICogU2VlIHRoZSB7QGxpbmsgU3dhbFBvcnRhbFRhcmdldHN9IHNlcnZpY2UgdG8gc2VlIHRoZSBhdmFpbGFibGUgdGFyZ2V0cy5cbiAgICAgKiBTZWUgdGhlIGNsYXNzIGRvYyBibG9jayBmb3IgbW9yZSBpbmZvcm1hdGlvbnMuXG4gICAgICovXG4gICAgQElucHV0KCdzd2FsUG9ydGFsJykgcHVibGljIHRhcmdldD86IFN3YWxQb3J0YWxUYXJnZXQ7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgY29tcG9uZW50IHJlZmVyZW5jZSBvZiB0aGUgY29udHJvbGxlZCBTd2FsUG9ydGFsQ29tcG9uZW50IHRvIGRlc3Ryb3kgaXQgd2hlbiBubyBsb25nZXIgbmVlZGVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgcG9ydGFsQ29tcG9uZW50UmVmPzogQ29tcG9uZW50UmVmPFN3YWxQb3J0YWxDb21wb25lbnQ+O1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBkZXN0cm95ZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGFwcDogQXBwbGljYXRpb25SZWYsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgc3dlZXRBbGVydDJMb2FkZXI6IFN3ZWV0QWxlcnQyTG9hZGVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBzd2FsVGFyZ2V0czogU3dhbFBvcnRhbFRhcmdldHMsXG4gICAgICAgIEBIb3N0KCkgcHJpdmF0ZSByZWFkb25seSBzd2FsQ29tcG9uZW50OiBTd2FsQ29tcG9uZW50KSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byB0aGUgdGhlIFN3ZWV0QWxlcnQgYXBwZWFyYW5jZS9kaXNhcHBlYXJhbmNlIGV2ZW50cyB0byBjcmVhdGUvZGVzdHJveSB0aGUgU3dhbFBvcnRhbENvbXBvbmVudFxuICAgICAqIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBjb25zdW1lcidzIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gQ2FuJ3QgYmUgc2V0IGluIGEgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSwgaWYgdGhlIGN1c3RvbWVyIGxldHMgKnN3YWxQb3J0YWwgZW1wdHksIHRoZSB2YWx1ZSB3ZSBnZXQgaXMgdW5kZWYuXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy50YXJnZXQgfHwgdGhpcy5zd2FsVGFyZ2V0cy5jb250ZW50O1xuXG4gICAgICAgIC8vPT4gQXBwbHkgdGhlIG9wdGlvbnMgcHJvdmlkZWQgYnkgdGhlIHRhcmdldCBkZWZpbml0aW9uXG4gICAgICAgIHZvaWQgdGhpcy5zd2FsQ29tcG9uZW50LnVwZGF0ZSh0aGlzLnRhcmdldC5vcHRpb25zKTtcblxuICAgICAgICAvLz0+IFN1YnNjcmliZSB0byBhIGZldyBob29rcyBmcm0gdGhlIHBhcmVudCBTd2FsQ29tcG9uZW50LlxuICAgICAgICB0aGlzLnN3YWxDb21wb25lbnQucmVuZGVyLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveWVkKSkuc3Vic2NyaWJlKHRoaXMucmVuZGVySG9vay5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zd2FsQ29tcG9uZW50LmJlZm9yZU9wZW4ucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQpKS5zdWJzY3JpYmUodGhpcy5iZWZvcmVPcGVuSG9vay5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zd2FsQ29tcG9uZW50LmFmdGVyQ2xvc2UucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQpKS5zdWJzY3JpYmUodGhpcy5hZnRlckNsb3NlSG9vay5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaWduYWwgYW55IHtAbGluayBkZXN0cm95ZWR9IGNvbnN1bWVyIHRoYXQgdGhpcyBpcyBvdmVyLCBzbyB0aGV5IGNhbiB1bnN1YnNjcmliZSBmcm9tIHRoZVxuICAgICAqIHBhcmVudCBTd2FsQ29tcG9uZW50IGV2ZW50cy5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkLm5leHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHJlbmRlciBob29rIHJ1bnMgMS4ubiB0aW1lcyAocGVyIG1vZGFsIGluc3RhbmNlKSwganVzdCBiZWZvcmUgdGhlIG1vZGFsIGlzIHNob3duIChhbmQgYWxzbyBiZWZvcmUgdGhlXG4gICAgICoge0BsaW5rIGJlZm9yZU9wZW5Ib29rfSksIG9yIGFmdGVyIFN3YWwudXBkYXRlKCkgaXMgY2FsbGVkLlxuICAgICAqIFRoaXMgaXMgYSBnb29kIHBsYWNlIHRvIHJlbmRlciwgb3IgcmUtcmVuZGVyLCBvdXIgcG9ydGFsIGNvbnRlbnRzLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgcmVuZGVySG9vaygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy89PiBFbnN1cmUgdGhlIHBvcnRhbCBjb21wb25lbnQgaXMgY3JlYXRlZFxuICAgICAgICBpZiAoIXRoaXMucG9ydGFsQ29tcG9uZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLnBvcnRhbENvbXBvbmVudFJlZiA9IHRoaXMuY3JlYXRlUG9ydGFsQ29tcG9uZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLz0+IFN3ZWV0QWxlcnQyIGNyZWF0ZWQgdGhlIG1vZGFsIG9yIGp1c3QgZXJhc2VkIGFsbCBvZiBvdXIgY29udGVudCwgc28gd2UgbmVlZCB0byBpbnN0YWxsL3JlaW5zdGFsbCBpdC5cbiAgICAgICAgLy8gU3dhbC51cGRhdGUoKSBpcyBzeW5jaHJvbm91cywgdGhpcyBvYnNlcnZhYmxlIHRvbywgYW5kIG1vdW50Q29tcG9uZW50T25UYXJnZXQgdG9vICh0aGUgcHJvbWlzZSBpbnNpZGVcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBpcyBhbHJlYWR5IHJlc29sdmVkIGF0IHRoaXMgcG9pbnQpLCBzbyB0aGUgd2hvbGUgcHJvY2VzcyBvZiByZS1yZW5kZXJpbmcgYW5kIHJlLW1vdW50aW5nXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgY29tcG9uZW50IGlzIGZ1bGx5IHN5bmNocm9ub3VzLCBjYXVzaW5nIG5vIGJsaW5rcyBpbiB0aGUgbW9kYWwgY29udGVudHMuXG4gICAgICAgIGNvbnN0IHN3YWwgPSBhd2FpdCB0aGlzLnN3ZWV0QWxlcnQyTG9hZGVyLnN3YWw7XG5cbiAgICAgICAgLy89PiBGaW5kIHRhcmdldCBlbGVtZW50XG4gICAgICAgIGNvbnN0IHRhcmdldEVsID0gdGhpcy50YXJnZXQhLmVsZW1lbnQoc3dhbCk7XG5cbiAgICAgICAgLy89PiBSZXBsYWNlIHRhcmdldCdzIGNvbnRlbnRzIHdpdGggb3VyIGNvbXBvbmVudFxuICAgICAgICAvLyBodHRwczovL2pzcGVyZi5jb20vaW5uZXJodG1sLXZzLXJlbW92ZWNoaWxkLzE1XG4gICAgICAgIHdoaWxlICh0YXJnZXRFbC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0YXJnZXRFbC5yZW1vdmVDaGlsZCh0YXJnZXRFbC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldEVsLmFwcGVuZENoaWxkKHRoaXMucG9ydGFsQ29tcG9uZW50UmVmLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYmVmb3JlT3BlbiBob29rIHJ1bnMgb25jZSAocGVyIG1vZGFsIGluc3RhbmNlKSwganVzdCBiZWZvcmUgdGhlIG1vZGFsIGlzIHNob3duIG9uIHRoZSBzY3JlZW4uXG4gICAgICogVGhpcyBpcyBhIGdvb2QgcGxhY2UgdG8gZGVjbGFyZSBvdXIgZGV0YWNoZWQgdmlldyB0byB0aGUgQW5ndWxhciBhcHAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBiZWZvcmVPcGVuSG9vaygpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnBvcnRhbENvbXBvbmVudFJlZikgcmV0dXJuO1xuXG4gICAgICAgIC8vPT4gTWFrZSB0aGUgQW5ndWxhciBhcHAgYXdhcmUgb2YgdGhhdCBkZXRhY2hlZCB2aWV3IHNvIHJlbmRlcmluZyBhbmQgY2hhbmdlIGRldGVjdGlvbiBjYW4gaGFwcGVuXG4gICAgICAgIHRoaXMuYXBwLmF0dGFjaFZpZXcodGhpcy5wb3J0YWxDb21wb25lbnRSZWYuaG9zdFZpZXcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYWZ0ZXJDbG9zZSBob29rIHJ1bnMgb25jZSAocGVyIG1vZGFsIGluc3RhbmNlKSwganVzdCBhZnRlciB0aGUgbW9kYWwgY2xvc2luZyBhbmltYXRpb24gdGVybWluYXRlZC5cbiAgICAgKiBUaGlzIGlzIGEgZ29vZCBwbGFjZSB0byBkZXRhY2ggYW5kIGRlc3Ryb3kgb3VyIGNvbnRlbnQsIHRoYXQgaXMgbm90IHZpc2libGUgYW55bW9yZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFmdGVyQ2xvc2VIb29rKCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMucG9ydGFsQ29tcG9uZW50UmVmKSByZXR1cm47XG5cbiAgICAgICAgLy89PiBEZXRhY2ggdGhlIHBvcnRhbCBjb21wb25lbnQgZnJvbSB0aGUgYXBwIGFuZCBkZXN0cm95IGl0XG4gICAgICAgIHRoaXMuYXBwLmRldGFjaFZpZXcodGhpcy5wb3J0YWxDb21wb25lbnRSZWYuaG9zdFZpZXcpO1xuICAgICAgICB0aGlzLnBvcnRhbENvbXBvbmVudFJlZi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucG9ydGFsQ29tcG9uZW50UmVmID0gdm9pZCAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHtAbGluayBTd2FsUG9ydGFsQ29tcG9uZW50fSBhbmQgZ2l2ZXMgaXQgdGhlIGN1c3RvbWVyJ3MgdGVtcGxhdGUgcmVmLlxuICAgICAqL1xuICAgIHByaXZhdGUgY3JlYXRlUG9ydGFsQ29tcG9uZW50KCk6IENvbXBvbmVudFJlZjxTd2FsUG9ydGFsQ29tcG9uZW50PiB7XG4gICAgICAgIC8vPT4gQ3JlYXRlIHRoZSBTd2FsUG9ydGFsQ29tcG9uZW50IHRoYXQgd2lsbCBob2xkIG91ciBjb250ZW50XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KFN3YWxQb3J0YWxDb21wb25lbnQpO1xuXG4gICAgICAgIC8vIFllcywgd2UgZG8gbm90IHVzZSB0aGUgdGhpcmQgYXJndW1lbnQgdGhhdCB3b3VsZCBkaXJlY3RseSB1c2UgdGhlIHRhcmdldCBhcyB0aGUgY29tcG9uZW50J3Mgdmlld1xuICAgICAgICAvLyAodW5mb3J0dW5hdGVseSwgYmVjYXVzZSB0aGF0IHdvdWxkIGdpdmUgYSBjbGVhbmVyIERPTSBhbmQgd291bGQgYXZvaWQgZGlydHkgYW5kIGRpcmVjdCBET00gbWFuaXB1bGF0aW9ucylcbiAgICAgICAgLy8gVGhhdCdzIGJlY2F1c2Ugd2Ugd2FudCB0byBrZWVwIG91ciBjb21wb25lbnQgc2FmZSBmcm9tIFN3ZWV0QWxlcnQyJ3Mgb3BlcmF0aW9ucyBvbiB0aGUgRE9NLCBhbmQgdG8gYmVcbiAgICAgICAgLy8gYWJsZSB0byByZXN0b3JlIGl0IGF0IGFueSBtb21lbnQsIGllLiBhZnRlciB0aGUgbW9kYWwgaGFzIGJlZW4gcmUtcmVuZGVyZWQuXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFJlZiA9IGZhY3RvcnkuY3JlYXRlKHRoaXMuaW5qZWN0b3IsIFtdKTtcblxuICAgICAgICAvLz0+IEFwcGx5IHRoZSBjb25zdW1lcidzIHRlbXBsYXRlIG9uIHRoZSBjb21wb25lbnRcbiAgICAgICAgY29tcG9uZW50UmVmLmluc3RhbmNlLnRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZVJlZjtcblxuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVmO1xuICAgIH1cbn1cbiJdfQ==