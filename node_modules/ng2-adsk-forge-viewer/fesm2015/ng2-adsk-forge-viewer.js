import { Injectable, EventEmitter, Component, ChangeDetectionStrategy, Output, Input, NgModule } from '@angular/core';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { __awaiter } from 'tslib';
import { map, takeUntil } from 'rxjs/operators';
import { fromEvent, merge, Subject } from 'rxjs';
import { DomSanitizer } from '@angular/platform-browser';

class ScriptService {
    constructor() {
        this.scripts = {};
        // Nothing to do
    }
    load(...urls) {
        const promises = [];
        urls.forEach((src) => {
            if (this.scripts[src] && this.scripts[src].loaded) {
                return;
            }
            this.scripts[src] = { src, loaded: false };
            return promises.push(this.loadScript(src));
        });
        return Promise.all(promises);
    }
    loadScript(name) {
        return new Promise((resolve, reject) => {
            // resolve if already loaded
            if (this.scripts[name] && this.scripts[name].loaded) {
                resolve({ src: name, loaded: true, status: 'Already Loaded' });
                return;
            }
            // load script
            const script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = this.scripts[name].src;
            if (script.readyState) { // IE
                script.onreadystatechange = () => {
                    if (script.readyState === 'loaded' || script.readyState === 'complete') {
                        script.onreadystatechange = null;
                        this.scripts[name].loaded = true;
                        resolve({ src: name, loaded: true, status: 'Loaded' });
                    }
                };
            }
            else { // Others
                script.onload = () => {
                    this.scripts[name].loaded = true;
                    resolve({ src: name, loaded: true, status: 'Loaded' });
                };
            }
            script.onerror = (error) => resolve({ src: name, loaded: false, status: 'Loaded' });
            document.getElementsByTagName('head')[0].appendChild(script);
        });
    }
}
ScriptService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ScriptService.ctorParameters = () => [];

/// <reference types="forge-viewer" />
class ViewerEventArgs {
}
class AggregationSelectionChangedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.AGGREGATE_SELECTION_CHANGED_EVENT;
    }
}
class AnimationReadyEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.ANIMATION_READY_EVENT;
    }
}
class CameraChangedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.CAMERA_CHANGE_EVENT;
    }
}
class CutplanesChangedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.CUTPLANES_CHANGE_EVENT;
    }
}
class EscapeEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.ESCAPE_EVENT;
    }
}
class ExplodeChangedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.EXPLODE_CHANGE_EVENT;
    }
}
class ExtensionLoadedUnloadedEventArgs extends ViewerEventArgs {
}
class ExtensionLoadedEventArgs extends ExtensionLoadedUnloadedEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.EXTENSION_LOADED_EVENT;
    }
}
class ExtensionUnloadedEventArgs extends ExtensionLoadedUnloadedEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.EXTENSION_UNLOADED_EVENT;
    }
}
class FinalFrameRenderedChangedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.FINAL_FRAME_RENDERED_CHANGED_EVENT;
    }
}
class FitToViewEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.FIT_TO_VIEW_EVENT;
    }
}
class FragmentsLoadedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.FRAGMENTS_LOADED_EVENT;
    }
}
class FullscreenEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.FULLSCREEN_MODE_EVENT;
    }
}
class GeometryLoadedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.GEOMETRY_LOADED_EVENT;
    }
}
class HideEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.HIDE_EVENT;
    }
}
class HyperlinkEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.HYPERLINK_EVENT;
    }
}
class IsolateEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.ISOLATE_EVENT;
    }
}
class LayerVisibilityEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.LAYER_VISIBILITY_CHANGED_EVENT;
    }
}
class LoadMissingGeometryEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.LOAD_MISSING_GEOMETRY;
    }
}
class ModelRootLoadedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT;
    }
}
class ModelUnloadedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.MODEL_UNLOADED_EVENT;
    }
}
class NavigationModeChangedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT;
    }
}
class ObjectTreeEventArgs extends ViewerEventArgs {
}
class ObjectTreeCreatedEventArgs extends ObjectTreeEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT;
    }
}
class ObjectTreeUnavailableEventArgs extends ObjectTreeEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.OBJECT_TREE_UNAVAILABLE_EVENT;
    }
}
class PrefEventArgs extends ViewerEventArgs {
}
class PrefChangedEventArgs extends PrefEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.PREF_CHANGED_EVENT;
    }
}
class PrefResetEventArgs extends PrefEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.PREF_RESET_EVENT;
    }
}
class ProgressUpdateEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.PROGRESS_UPDATE_EVENT;
    }
}
class RenderOptionChangedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT;
    }
}
class RenderPresentedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.RENDER_PRESENTED_EVENT;
    }
}
class ResetEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.RESET_EVENT;
    }
}
class RestoreDefaultSettingsEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.RESTORE_DEFAULT_SETTINGS_EVENT;
    }
}
class SelectionChangedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.SELECTION_CHANGED_EVENT;
    }
}
class ShowEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.SHOW_EVENT;
    }
}
class TexturesLoadedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.TEXTURES_LOADED_EVENT;
    }
}
class ToolChangedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.TOOL_CHANGE_EVENT;
    }
}
class ViewerInitializedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.VIEWER_INITIALIZED;
    }
}
class ViewerResizeEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.VIEWER_RESIZE_EVENT;
    }
}
class ViewerStateRestoredEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.VIEWER_STATE_RESTORED_EVENT;
    }
}
class ViewerUnInitializedEventArgs extends ViewerEventArgs {
    constructor() {
        super(...arguments);
        this.type = Autodesk.Viewing.VIEWER_UNINITIALIZED;
    }
}
/**
 * Base extension that all other extensions can inherit from
 */
class Extension {
    constructor(viewer, options) {
        this.viewer = undefined;
        this.extOptions = undefined;
        this.eventArgsTypeMap = {};
        this.viewer = viewer;
        this.extOptions = options;
        this.registerEventTypes();
    }
    static registerExtension(extensionName, extension) {
        Autodesk.Viewing.theExtensionManager.registerExtension(extensionName, extension);
    }
    static unregisterExtension(extensionName) {
        Autodesk.Viewing.theExtensionManager.unregisterExtension(extensionName);
    }
    /** Register event args types that we will cast to 'proper' objects */
    registerEventTypes() {
        // tslint:disable:max-line-length
        this.eventArgsTypeMap[Autodesk.Viewing.AGGREGATE_SELECTION_CHANGED_EVENT] = AggregationSelectionChangedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.ANIMATION_READY_EVENT] = AnimationReadyEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.CAMERA_CHANGE_EVENT] = CameraChangedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.CUTPLANES_CHANGE_EVENT] = CutplanesChangedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.ESCAPE_EVENT] = EscapeEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.EXPLODE_CHANGE_EVENT] = ExplodeChangedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.EXTENSION_LOADED_EVENT] = ExtensionLoadedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.EXTENSION_UNLOADED_EVENT] = ExtensionUnloadedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.FINAL_FRAME_RENDERED_CHANGED_EVENT] = FinalFrameRenderedChangedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.FIT_TO_VIEW_EVENT] = FitToViewEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.FRAGMENTS_LOADED_EVENT] = FragmentsLoadedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.FULLSCREEN_MODE_EVENT] = FullscreenEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.GEOMETRY_LOADED_EVENT] = GeometryLoadedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.HIDE_EVENT] = HideEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.HYPERLINK_EVENT] = HyperlinkEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.ISOLATE_EVENT] = IsolateEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.LAYER_VISIBILITY_CHANGED_EVENT] = LayerVisibilityEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.LOAD_MISSING_GEOMETRY] = LoadMissingGeometryEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT] = ModelRootLoadedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.MODEL_UNLOADED_EVENT] = ModelUnloadedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT] = NavigationModeChangedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT] = ObjectTreeCreatedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.OBJECT_TREE_UNAVAILABLE_EVENT] = ObjectTreeUnavailableEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.PREF_CHANGED_EVENT] = PrefChangedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.PREF_RESET_EVENT] = PrefResetEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.PROGRESS_UPDATE_EVENT] = ProgressUpdateEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT] = RenderOptionChangedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.RENDER_PRESENTED_EVENT] = RenderPresentedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.RESET_EVENT] = ResetEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.RESTORE_DEFAULT_SETTINGS_EVENT] = RestoreDefaultSettingsEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.SELECTION_CHANGED_EVENT] = SelectionChangedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.SHOW_EVENT] = ShowEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.TEXTURES_LOADED_EVENT] = TexturesLoadedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.TOOL_CHANGE_EVENT] = ToolChangedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.VIEWER_INITIALIZED] = ViewerInitializedEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.VIEWER_RESIZE_EVENT] = ViewerResizeEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.VIEWER_STATE_RESTORED_EVENT] = ViewerStateRestoredEventArgs;
        this.eventArgsTypeMap[Autodesk.Viewing.VIEWER_UNINITIALIZED] = ViewerUnInitializedEventArgs;
        // tslint:enable:max-line-length
    }
    /** Cast Viewer event args to class */
    castArgs(args) {
        if (Array.isArray(args)) {
            return args.map(this.castArgs);
        }
        if (!args || typeof args !== 'object' || !args.hasOwnProperty('type')) {
            // Can't cast this object
            return args;
        }
        // Create new object of appropriate type
        const clazz = this.eventArgsTypeMap[args.type];
        const typedItem = Object.create(clazz.prototype);
        // Cast any properties
        for (const k of Object.keys(args)) {
            typedItem[k] = this.castArgs(args[k]);
        }
        return typedItem;
    }
}
Extension.extensionName = '';

class BasicExtension extends Extension {
    constructor() {
        super(...arguments);
        this.eventStreams = [];
        this.events = [
            Autodesk.Viewing.FIT_TO_VIEW_EVENT,
            Autodesk.Viewing.FULLSCREEN_MODE_EVENT,
            Autodesk.Viewing.GEOMETRY_LOADED_EVENT,
            Autodesk.Viewing.HIDE_EVENT,
            Autodesk.Viewing.ISOLATE_EVENT,
            Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT,
            Autodesk.Viewing.OBJECT_TREE_UNAVAILABLE_EVENT,
            Autodesk.Viewing.RESET_EVENT,
            Autodesk.Viewing.SELECTION_CHANGED_EVENT,
            Autodesk.Viewing.SHOW_EVENT,
        ];
    }
    static registerExtension(extensionName, callback) {
        BasicExtension.callback = callback;
        super.registerExtension(BasicExtension.extensionName, BasicExtension);
    }
    load() {
        this.events.forEach((eventName) => {
            const obs = fromEvent(this.viewer, eventName).pipe(map(args => this.castArgs(args)));
            this.eventStreams.push(obs);
        });
        this.viewerEvents = merge(...this.eventStreams);
        if (BasicExtension.debugMessages)
            console.log(BasicExtension.extensionName, 'loaded!');
        if (BasicExtension.callback)
            BasicExtension.callback(this);
        return true;
    }
    unload() {
        this.eventStreams = [];
        this.viewerEvents = undefined;
        if (BasicExtension.debugMessages)
            console.log(BasicExtension.extensionName, 'unloaded!');
        return true;
    }
    activate() {
        return true;
    }
    deactivate() {
        return true;
    }
}
BasicExtension.extensionName = 'BasicExtension';
BasicExtension.debugMessages = false;
BasicExtension.callback = null;

class ViewerComponent {
    constructor(script) {
        this.script = script;
        this.onDocumentChanged = new EventEmitter();
        this.onItemLoaded = new EventEmitter();
        this.onError = new EventEmitter();
        // Viewer events
        this.onFitToView = new EventEmitter();
        this.onFullscreen = new EventEmitter();
        this.onGeometryLoaded = new EventEmitter();
        this.onHide = new EventEmitter();
        this.onIsolate = new EventEmitter();
        this.onObjectTreeCreated = new EventEmitter();
        this.onObjectTreeUnavailable = new EventEmitter();
        this.onReset = new EventEmitter();
        this.onSelectionChanged = new EventEmitter();
        this.onShow = new EventEmitter();
        // Debugging
        this.showDebugMessages = false;
        this._viewerOptions = null;
        this.viewerInitialized = false;
        this.unsubscribe = new Subject();
        this.containerId = this.getDivName();
    }
    /**
     * Helper to allow callers to specify documentId with or without the required urn: prefix
     */
    static verifyUrn(documentId) {
        return (documentId.startsWith('urn:')) ? documentId : `urn:${documentId}`;
    }
    set viewerOptions(options) {
        if (!this.viewerInitialized && options) {
            this._viewerOptions = options;
            void this.initialiseViewer();
        }
    }
    get viewerOptions() {
        return this._viewerOptions;
    }
    ngOnDestroy() {
        this.unregisterBasicExtension();
        if (this.viewer) {
            this.viewer.tearDown();
            this.viewer.uninitialize();
        }
        this.viewer = null;
        this.viewerInitialized = false;
        this.unsubscribe.next();
        this.unsubscribe.complete();
    }
    /**
     * Helper method to get some default viewer options
     */
    getDefaultViewerOptions(onViewerInitialized, getAccessToken) {
        return {
            initializerOptions: {
                env: 'AutodeskProduction',
                getAccessToken,
                api: 'derivativeV2',
            },
            onViewerInitialized,
        };
    }
    /**
     * Get a reference to the current 3D viewer
     */
    get Viewer3D() {
        return this.viewer;
    }
    /**
     * Get the document urn that has been loaded
     */
    get DocumentId() {
        return this.documentId;
    }
    /**
     * Set the document urn, which triggers the viewer to load the document
     */
    set DocumentId(value) {
        this.documentId = value;
        this.loadModel(this.documentId);
    }
    /**
     * Get the container element
     */
    get Container() {
        return document.getElementById(this.containerId);
    }
    /**
     * Get the id assigned to the viewer
     */
    get ContainerId() {
        return this.containerId;
    }
    get basicExtension() {
        return this.basicExt;
    }
    get extensionEvents() {
        if (this.basicExt) {
            return this.basicExt.viewerEvents;
        }
    }
    loadDocumentNode(document, bubbleNode, options) {
        return this.viewer.loadDocumentNode(document, bubbleNode, options);
    }
    /**
     * We don't bundle Autodesk's scripts with the component, and we don't really want users to have
     * to add the scripts to their index.html pages. So we'll load them when required.
     */
    loadScripts() {
        const version = this.viewerOptions.version || '7.*';
        const url = `https://developer.api.autodesk.com/modelderivative/v2/viewers/${version}/viewer3D.min.js`;
        return this.script.load(url)
            .then((data) => {
            this.log('script loaded ', data);
        })
            .catch(error => this.error(error));
    }
    /**
     * Initialises the viewer
     */
    initialiseViewer() {
        return __awaiter(this, void 0, void 0, function* () {
            // Load scripts first
            yield this.loadScripts();
            if (this.viewerOptions.onViewerScriptsLoaded)
                this.viewerOptions.onViewerScriptsLoaded();
            // Check if the viewer has already been initialised - this isn't the nicest, but we've set the env in our
            // options above so we at least know that it was us who did this!
            if (!Autodesk.Viewing.Private.env) {
                Autodesk.Viewing.Initializer(this.viewerOptions.initializerOptions, () => {
                    this.initialized();
                });
            }
            else {
                // We need to give an initialised viewing application a tick to allow the DOM element
                // to be established before we re-draw
                setTimeout(() => {
                    this.initialized();
                });
            }
        });
    }
    initialized() {
        var _a, _b;
        // Register an extension to help us raise events
        const extName = this.registerBasicExtension();
        const config = this.addBasicExtensionConfig(extName);
        // Support large models
        if (this.viewerOptions.enableMemoryManagement) {
            config.loaderExtensions = { svf: 'Autodesk.MemoryLimited' };
        }
        // Create a new viewer
        if (this.viewerOptions.headlessViewer) {
            this.viewer = new Autodesk.Viewing.Viewer3D(this.Container, config);
        }
        else {
            this.viewer = new Autodesk.Viewing.GuiViewer3D(this.Container, config);
        }
        // set a document url if environment set to Local
        let url;
        if (((_a = this.viewerOptions.initializerOptions) === null || _a === void 0 ? void 0 : _a.env) === 'Local') {
            url = (_b = this.viewerOptions.initializerOptions) === null || _b === void 0 ? void 0 : _b.document;
        }
        // Start the viewer
        this.viewer.start(url);
        // Viewer is ready - scripts are loaded and we've create a new viewing application
        this.viewerInitialized = true;
        this.viewerOptions.onViewerInitialized({ viewerComponent: this, viewer: this.viewer });
    }
    /**
     * Loads a model in to the viewer via it's urn
     */
    loadModel(documentId) {
        if (!documentId) {
            return;
        }
        // Add urn: to the beginning of document id if needed
        Autodesk.Viewing.Document.load(ViewerComponent.verifyUrn(documentId), this.onDocumentLoadSuccess.bind(this), this.onDocumentLoadFailure.bind(this));
    }
    /**
     * Document successfully loaded
     */
    onDocumentLoadSuccess(document) {
        if (!document.getRoot())
            return;
        // Emit an event so the caller can do something
        // TODO: config option to specify which viewable to display (how?)
        this.onDocumentChanged.emit({ document, viewerComponent: this, viewer: this.viewer });
        if (this.viewerOptions.showFirstViewable === undefined || this.viewerOptions.showFirstViewable) {
            let model = document.getRoot().getDefaultGeometry();
            if (!model) {
                const allModels = document.getRoot().search({ type: 'geometry' });
                model = allModels[0];
            }
            void this.viewer.loadDocumentNode(document, model, undefined);
        }
    }
    /**
     * Failed to load document
     */
    onDocumentLoadFailure(errorCode) {
        this.error('onDocumentLoadFailure() - errorCode:' + errorCode);
        this.onError.emit(errorCode);
    }
    /**
     * Register our BasicExtension with the Forge Viewer
     */
    registerBasicExtension() {
        BasicExtension.registerExtension(BasicExtension.extensionName, this.extensionLoaded.bind(this));
        return BasicExtension.extensionName;
    }
    /**
     * Subscript to BasicExtension events when the extension has been
     * succesfully loaded by the viewer.
     */
    extensionLoaded(ext) {
        this.basicExt = ext;
        ext.viewerEvents
            .pipe(takeUntil(this.unsubscribe))
            .subscribe((item) => {
            this.log(item);
            if (item instanceof FitToViewEventArgs) {
                this.onFitToView.emit(item);
            }
            else if (item instanceof FullscreenEventArgs) {
                this.onFullscreen.emit(item);
            }
            else if (item instanceof GeometryLoadedEventArgs) {
                this.onGeometryLoaded.emit(item);
            }
            else if (item instanceof HideEventArgs) {
                this.onHide.emit(item);
            }
            else if (item instanceof IsolateEventArgs) {
                this.onIsolate.emit(item);
            }
            else if (item instanceof ObjectTreeCreatedEventArgs) {
                this.onObjectTreeCreated.emit(item);
            }
            else if (item instanceof ObjectTreeUnavailableEventArgs) {
                this.onObjectTreeUnavailable.emit(item);
            }
            else if (item instanceof ResetEventArgs) {
                this.onReset.emit(item);
            }
            else if (item instanceof SelectionChangedEventArgs) {
                this.onSelectionChanged.emit(item);
            }
            else if (item instanceof ShowEventArgs) {
                this.onShow.emit(item);
            }
        });
    }
    unregisterBasicExtension() {
        BasicExtension.unregisterExtension(BasicExtension.extensionName);
        this.basicExt = null;
    }
    /**
     * Add list of extensions to the viewer config that has been provided
     * The allows the user to register their own extensions.
     */
    addBasicExtensionConfig(extName) {
        const config = Object.assign({}, this.viewerOptions.viewerConfig, { extensions: [] });
        // We will always load our basic extension with any others specified by the caller
        if (this.viewerOptions.viewerConfig && this.viewerOptions.viewerConfig.extensions) {
            config.extensions = [...this.viewerOptions.viewerConfig.extensions, extName];
        }
        else {
            config.extensions = [extName];
        }
        return config;
    }
    log(message, ...optionalParams) {
        if (!this.showDebugMessages)
            return;
        console.log(message, optionalParams);
    }
    error(message, ...optionalParams) {
        if (!this.showDebugMessages)
            return;
        console.error(message, optionalParams);
    }
    getDivName() {
        const S4 = () => {
            // tslint:disable-next-line:no-bitwise
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };
        const guid = (S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4());
        return `viewer_${guid}`;
    }
}
ViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adsk-forge-viewer',
                template: "<div [id]=\"containerId\" class=\"forge-viewer-container\"></div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: ["@import url(\"https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.min.css\");"]
            },] }
];
/** @nocollapse */
ViewerComponent.ctorParameters = () => [
    { type: ScriptService }
];
ViewerComponent.propDecorators = {
    onDocumentChanged: [{ type: Output }],
    onItemLoaded: [{ type: Output }],
    onError: [{ type: Output }],
    onFitToView: [{ type: Output }],
    onFullscreen: [{ type: Output }],
    onGeometryLoaded: [{ type: Output }],
    onHide: [{ type: Output }],
    onIsolate: [{ type: Output }],
    onObjectTreeCreated: [{ type: Output }],
    onObjectTreeUnavailable: [{ type: Output }],
    onReset: [{ type: Output }],
    onSelectionChanged: [{ type: Output }],
    onShow: [{ type: Output }],
    showDebugMessages: [{ type: Input }],
    viewerOptions: [{ type: Input }]
};

class ThumbnailComponent {
    constructor(http, sanitizer) {
        this.http = http;
        this.sanitizer = sanitizer;
    }
    ngOnChanges() {
        if (this.thumbnailOptions) {
            this.setImageSrc(this.thumbnailOptions.defaultImageSrc);
            this.getThumbnail(this.thumbnailOptions.documentId);
        }
    }
    getThumbnail(documentId) {
        let url = `https://developer.api.autodesk.com/modelderivative/v2/designdata/${documentId}/thumbnail`;
        let opts = '';
        if (this.thumbnailOptions.width)
            opts += `width=${this.thumbnailOptions.width}&`;
        if (this.thumbnailOptions.height)
            opts += `height=${this.thumbnailOptions.height}&`;
        if (opts)
            url += `?${opts.slice(0, -1)}`;
        this.thumbnailOptions.getAccessToken(this.setAccessToken.bind(this));
        const headers = {
            Authorization: `Bearer ${this.token}`,
            'Content-Type': 'image/png',
        };
        this.http.get(url, { headers, responseType: 'arraybuffer' })
            .subscribe(data => (data) ? this.setImageSrc(`data:image/png;base64,${this.toBase64(data)}`)
            : this.setImageSrc(), error => this.setImageSrc());
    }
    setAccessToken(accessToken, expiryTime) {
        this.token = accessToken;
        this.expire = expiryTime;
    }
    toBase64(data) {
        return btoa(String.fromCharCode(...new Uint8Array(data)));
    }
    setImageSrc(src = '') {
        let imageSrc = '';
        if (src) {
            imageSrc = src;
        }
        else {
            imageSrc = (this.thumbnailOptions && this.thumbnailOptions.defaultImageSrc) || '';
        }
        this.imageSrc = this.sanitizer.bypassSecurityTrustUrl(imageSrc);
    }
}
ThumbnailComponent.decorators = [
    { type: Component, args: [{
                selector: 'adsk-forge-thumbnail',
                template: "<img [src]=\"imageSrc\" />\n"
            },] }
];
/** @nocollapse */
ThumbnailComponent.ctorParameters = () => [
    { type: HttpClient },
    { type: DomSanitizer }
];
ThumbnailComponent.propDecorators = {
    thumbnailOptions: [{ type: Input }]
};

class ViewerModule {
}
ViewerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ViewerComponent, ThumbnailComponent],
                imports: [HttpClientModule],
                exports: [ViewerComponent, ThumbnailComponent],
                providers: [ScriptService],
            },] }
];

/*
 * Public API Surface of ng2-adsk-forge-viewer
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AggregationSelectionChangedEventArgs, AnimationReadyEventArgs, BasicExtension, CameraChangedEventArgs, CutplanesChangedEventArgs, EscapeEventArgs, ExplodeChangedEventArgs, Extension, ExtensionLoadedEventArgs, ExtensionLoadedUnloadedEventArgs, ExtensionUnloadedEventArgs, FinalFrameRenderedChangedEventArgs, FitToViewEventArgs, FragmentsLoadedEventArgs, FullscreenEventArgs, GeometryLoadedEventArgs, HideEventArgs, HyperlinkEventArgs, IsolateEventArgs, LayerVisibilityEventArgs, LoadMissingGeometryEventArgs, ModelRootLoadedEventArgs, ModelUnloadedEventArgs, NavigationModeChangedEventArgs, ObjectTreeCreatedEventArgs, ObjectTreeEventArgs, ObjectTreeUnavailableEventArgs, PrefChangedEventArgs, PrefEventArgs, PrefResetEventArgs, ProgressUpdateEventArgs, RenderOptionChangedEventArgs, RenderPresentedEventArgs, ResetEventArgs, RestoreDefaultSettingsEventArgs, ScriptService, SelectionChangedEventArgs, ShowEventArgs, TexturesLoadedEventArgs, ThumbnailComponent, ToolChangedEventArgs, ViewerComponent, ViewerEventArgs, ViewerInitializedEventArgs, ViewerModule, ViewerResizeEventArgs, ViewerStateRestoredEventArgs, ViewerUnInitializedEventArgs };
//# sourceMappingURL=ng2-adsk-forge-viewer.js.map
