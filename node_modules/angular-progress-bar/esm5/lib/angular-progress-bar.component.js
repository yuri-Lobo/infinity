/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, Input } from '@angular/core';
var ProgressBarComponent = /** @class */ (function () {
    function ProgressBarComponent() {
        // Default color
        this.color = "#488aff";
        this.disabledP = false;
    }
    /**
     * Returns a color for a certain percent
     * @param percent The current progress
     */
    /**
     * Returns a color for a certain percent
     * @param {?} percent The current progress
     * @return {?}
     */
    ProgressBarComponent.prototype.whichColor = /**
     * Returns a color for a certain percent
     * @param {?} percent The current progress
     * @return {?}
     */
    function (percent) {
        var e_1, _a;
        // Get all entries index as an array
        /** @type {?} */
        var k = Object.keys(this.degraded);
        // Convert string to number
        k.forEach(function (e, i) { return k[i] = +e; });
        // Sort them by value
        k = k.sort(function (a, b) { return a - b; });
        // Percent as number
        /** @type {?} */
        var p = +percent
        // Set last by default as the first occurrence
        ;
        // Set last by default as the first occurrence
        /** @type {?} */
        var last = k[0];
        try {
            // Foreach keys 
            for (var k_1 = tslib_1.__values(k), k_1_1 = k_1.next(); !k_1_1.done; k_1_1 = k_1.next()) {
                var val = k_1_1.value;
                // if current val is < than percent
                if (val < p) {
                    last = val;
                }
                // if val >= percent then the val that we could show has been reached
                else if (val >= p - 1) {
                    return this.degraded[last];
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (k_1_1 && !k_1_1.done && (_a = k_1.return)) _a.call(k_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // if its the last one return the last
        return this.degraded[last];
    };
    /**
     * @param {?} progress
     * @return {?}
     */
    ProgressBarComponent.prototype.whichProgress = /**
     * @param {?} progress
     * @return {?}
     */
    function (progress) {
        try {
            return Math.round(+progress * 100) / 100;
        }
        catch (_a) {
            return progress;
        }
    };
    ProgressBarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'progress-bar',
                    template: "\n  <div class=\"progress-outer\">\n    <div class=\"progress-inner\" [style.width]=\"whichProgress(progress) + '%'\" [style.background-color]=\"degraded == null ? color : whichColor(progress)\">\n      <ng-container *ngIf=\"!disabledP\"> \n        {{whichProgress(progress)}}%\n      </ng-container>\n      <ng-container *ngIf=\"disabledP\"> \n        {{whichProgress(progress)}}\n      </ng-container>\n    </div>\n  </div>\n  ",
                    styles: ["\n        .progress-outer {\n          width: 96%;\n          margin: 10px 2%;\n          padding: 3px;\n          background-color: #f4f4f4;\n          border: 1px solid #dcdcdc;\n          color: #fff;\n          border-radius: 20px;\n          text-align: center;\n        }\n        .progress-inner {\n          min-width: 15%;\n          min-height:18px;\n          white-space: nowrap;\n          overflow: hidden;\n          padding: 0px;\n          border-radius: 20px;\n  "]
                }] }
    ];
    /** @nocollapse */
    ProgressBarComponent.ctorParameters = function () { return []; };
    ProgressBarComponent.propDecorators = {
        progress: [{ type: Input, args: ['progress',] }],
        color: [{ type: Input, args: ['color',] }],
        degraded: [{ type: Input, args: ['color-degraded',] }],
        disabledP: [{ type: Input, args: ['disable-percentage',] }]
    };
    return ProgressBarComponent;
}());
export { ProgressBarComponent };
if (false) {
    /**
     * Inputs *
     * @type {?}
     */
    ProgressBarComponent.prototype.progress;
    /** @type {?} */
    ProgressBarComponent.prototype.color;
    /** @type {?} */
    ProgressBarComponent.prototype.degraded;
    /** @type {?} */
    ProgressBarComponent.prototype.disabledP;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1wcm9ncmVzcy1iYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1wcm9ncmVzcy1iYXIvIiwic291cmNlcyI6WyJsaWIvYW5ndWxhci1wcm9ncmVzcy1iYXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFakQ7SUE2Q0E7UUFDRSxnQkFBZ0I7UUFDaEIsSUFBSSxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUM7UUFDdkIsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7T0FHRzs7Ozs7O0lBQ0gseUNBQVU7Ozs7O0lBQVYsVUFBVyxPQUFlOzs7O1lBRXBCLENBQUMsR0FBZSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDOUMsMkJBQTJCO1FBQzNCLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQyxJQUFLLE9BQUEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFULENBQVMsQ0FBQyxDQUFDO1FBQy9CLHFCQUFxQjtRQUNyQixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFDLENBQUMsRUFBRSxDQUFDLElBQUssT0FBQSxDQUFDLEdBQUcsQ0FBQyxFQUFMLENBQUssQ0FBQyxDQUFDOzs7WUFFeEIsQ0FBQyxHQUFHLENBQUMsT0FBTztRQUNoQiw4Q0FBOEM7Ozs7WUFDMUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7O1lBQ2YsZ0JBQWdCO1lBQ2hCLEtBQWUsSUFBQSxNQUFBLGlCQUFBLENBQUMsQ0FBQSxvQkFBQSxtQ0FBQztnQkFBYixJQUFJLEdBQUcsY0FBQTtnQkFDVCxtQ0FBbUM7Z0JBQ25DLElBQUcsR0FBRyxHQUFHLENBQUMsRUFBQztvQkFDVCxJQUFJLEdBQUcsR0FBRyxDQUFDO2lCQUNaO2dCQUNELHFFQUFxRTtxQkFDaEUsSUFBRyxHQUFHLElBQUksQ0FBQyxHQUFFLENBQUMsRUFBQztvQkFDbEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUM1QjthQUNGOzs7Ozs7Ozs7UUFDRCxzQ0FBc0M7UUFDdEMsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzdCLENBQUM7Ozs7O0lBRUQsNENBQWE7Ozs7SUFBYixVQUFjLFFBQWdCO1FBQzVCLElBQUc7WUFDRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO1NBQzFDO1FBQ0QsV0FBSztZQUNILE9BQU8sUUFBUSxDQUFDO1NBQ2pCO0lBQ0gsQ0FBQzs7Z0JBeEZBLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQ0osY0FBYztvQkFvQmxCLFFBQVEsRUFDUiwrYUFXQzs2QkEvQlEsbWVBa0JSO2lCQWNGOzs7OzsyQkFJRSxLQUFLLFNBQUMsVUFBVTt3QkFDaEIsS0FBSyxTQUFDLE9BQU87MkJBQ2IsS0FBSyxTQUFDLGdCQUFnQjs0QkFDdEIsS0FBSyxTQUFDLG9CQUFvQjs7SUErQzdCLDJCQUFDO0NBQUEsQUF6RkQsSUF5RkM7U0FyRFksb0JBQW9COzs7Ozs7SUFHL0Isd0NBQW9DOztJQUNwQyxxQ0FBOEI7O0lBQzlCLHdDQUF1Qzs7SUFDdkMseUNBQWdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6XHJcbiAgICAgICdwcm9ncmVzcy1iYXInLFxyXG4gIHN0eWxlczogW2BcclxuICAgICAgICAucHJvZ3Jlc3Mtb3V0ZXIge1xyXG4gICAgICAgICAgd2lkdGg6IDk2JTtcclxuICAgICAgICAgIG1hcmdpbjogMTBweCAyJTtcclxuICAgICAgICAgIHBhZGRpbmc6IDNweDtcclxuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XHJcbiAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZGNkY2RjO1xyXG4gICAgICAgICAgY29sb3I6ICNmZmY7XHJcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xyXG4gICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAucHJvZ3Jlc3MtaW5uZXIge1xyXG4gICAgICAgICAgbWluLXdpZHRoOiAxNSU7XHJcbiAgICAgICAgICBtaW4taGVpZ2h0OjE4cHg7XHJcbiAgICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xyXG4gICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgICAgICAgIHBhZGRpbmc6IDBweDtcclxuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDIwcHg7XHJcbiAgYF0sXHJcbiAgdGVtcGxhdGU6XHJcbiAgYFxyXG4gIDxkaXYgY2xhc3M9XFxcInByb2dyZXNzLW91dGVyXFxcIj5cclxuICAgIDxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWlubmVyXFxcIiBbc3R5bGUud2lkdGhdPVxcXCJ3aGljaFByb2dyZXNzKHByb2dyZXNzKSArICclJ1xcXCIgW3N0eWxlLmJhY2tncm91bmQtY29sb3JdPVxcXCJkZWdyYWRlZCA9PSBudWxsID8gY29sb3IgOiB3aGljaENvbG9yKHByb2dyZXNzKVxcXCI+XHJcbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhZGlzYWJsZWRQXCI+IFxyXG4gICAgICAgIHt7d2hpY2hQcm9ncmVzcyhwcm9ncmVzcyl9fSVcclxuICAgICAgPC9uZy1jb250YWluZXI+XHJcbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJkaXNhYmxlZFBcIj4gXHJcbiAgICAgICAge3t3aGljaFByb2dyZXNzKHByb2dyZXNzKX19XHJcbiAgICAgIDwvbmctY29udGFpbmVyPlxyXG4gICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbiAgYFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUHJvZ3Jlc3NCYXJDb21wb25lbnQge1xyXG5cclxuLyoqIElucHV0cyAqKi9cclxuICBASW5wdXQoJ3Byb2dyZXNzJykgcHJvZ3Jlc3M6IHN0cmluZztcclxuICBASW5wdXQoJ2NvbG9yJykgY29sb3I6IHN0cmluZztcclxuICBASW5wdXQoJ2NvbG9yLWRlZ3JhZGVkJykgZGVncmFkZWQ6IGFueTtcclxuICBASW5wdXQoJ2Rpc2FibGUtcGVyY2VudGFnZScpIGRpc2FibGVkUDogYm9vbGVhbjtcclxuXHJcblxyXG5jb25zdHJ1Y3RvcigpIHtcclxuICAvLyBEZWZhdWx0IGNvbG9yXHJcbiAgdGhpcy5jb2xvciA9IFwiIzQ4OGFmZlwiO1xyXG4gIHRoaXMuZGlzYWJsZWRQID0gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29sb3IgZm9yIGEgY2VydGFpbiBwZXJjZW50XHJcbiAqIEBwYXJhbSBwZXJjZW50IFRoZSBjdXJyZW50IHByb2dyZXNzXHJcbiAqL1xyXG53aGljaENvbG9yKHBlcmNlbnQ6IHN0cmluZyl7XHJcbiAgLy8gR2V0IGFsbCBlbnRyaWVzIGluZGV4IGFzIGFuIGFycmF5XHJcbiAgbGV0IGs6IEFycmF5PGFueT4gPSBPYmplY3Qua2V5cyh0aGlzLmRlZ3JhZGVkKTtcclxuICAvLyBDb252ZXJ0IHN0cmluZyB0byBudW1iZXJcclxuICBrLmZvckVhY2goKGUsIGkpID0+IGtbaV0gPSArZSk7XHJcbiAgLy8gU29ydCB0aGVtIGJ5IHZhbHVlXHJcbiAgayA9IGsuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gIC8vIFBlcmNlbnQgYXMgbnVtYmVyXHJcbiAgbGV0IHAgPSArcGVyY2VudFxyXG4gIC8vIFNldCBsYXN0IGJ5IGRlZmF1bHQgYXMgdGhlIGZpcnN0IG9jY3VycmVuY2VcclxuICBsZXQgbGFzdCA9IGtbMF07XHJcbiAgLy8gRm9yZWFjaCBrZXlzIFxyXG4gIGZvcihsZXQgdmFsIG9mIGspe1xyXG4gICAgLy8gaWYgY3VycmVudCB2YWwgaXMgPCB0aGFuIHBlcmNlbnRcclxuICAgIGlmKHZhbCA8IHApe1xyXG4gICAgICBsYXN0ID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgdmFsID49IHBlcmNlbnQgdGhlbiB0aGUgdmFsIHRoYXQgd2UgY291bGQgc2hvdyBoYXMgYmVlbiByZWFjaGVkXHJcbiAgICBlbHNlIGlmKHZhbCA+PSBwIC0xKXtcclxuICAgICAgcmV0dXJuIHRoaXMuZGVncmFkZWRbbGFzdF07XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIGlmIGl0cyB0aGUgbGFzdCBvbmUgcmV0dXJuIHRoZSBsYXN0XHJcbiAgcmV0dXJuIHRoaXMuZGVncmFkZWRbbGFzdF07XHJcbn1cclxuXHJcbndoaWNoUHJvZ3Jlc3MocHJvZ3Jlc3M6IHN0cmluZyl7XHJcbiAgdHJ5e1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoK3Byb2dyZXNzICogMTAwKSAvIDEwMDtcclxuICB9XHJcbiAgY2F0Y2h7XHJcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XHJcbiAgfVxyXG59XHJcbn0iXX0=